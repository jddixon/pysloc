#!/usr/bin/python3

# pySloc, part of pysloc

import fnmatch
import os
import re
import sys
import time
from argparse import ArgumentParser
from xlattice.util import makeExRE
from stat import *

from pysloc import *


def readFileMap(pathToFile, namedFiles):
    """
    Read a file, stripping off comments beginning with sharp signs ('#')
    and dropping blank lines.  What remains should look like
    LANG:VISIBILITY:REL_PATH.  For the moment we ignore pseudo-languages
    'file' and 'dir' and the visibility column. NOT TRUE: these are NOT
    ignored.
    """
    with open(pathToFile, 'rb') as f:
        data = f.read().decode('utf-8')
    if data:
        lines = data.split('\n')
        if lines[-1] == '':
            lines = lines[:-1]
        for line in lines:
            # get rid of comments
            line, junk, trash = line.partition('#')
            line = line.strip()
            if line:
                parts = line.split(':')
                if len(parts) == 3:
                    # line is well-formed, by a crude standard
                    eLang, viz, relPath = parts

                    item = eLang + ':' + relPath
                    # DEBUG
                    # print("adding '%s' to named file list" % item)
                    # END
                    namedFiles.append(item)
                else:
                    print("%s: can't interpret '%s'" % (pathToFile, line))


def doCount(options):

    # get and check options; XXX should throw exceptions if problems
    # are encountered

    exclusions = options.exclusions
    exRE = options.exRE
    justShow = options.justShow
    k = options.k
    projCfg = options.projCfg           # this is projCfg.local
    langsCounted = options.langsCounted
    mainLang = options.mainLang
    matches = options.matches
    namedFiles = options.namedFiles
    onlyNamedFiles = options.onlyNamedFiles
    q = options.q
    showTimestamp = options.showTimestamp
    showVersion = options.showVersion
    sumSLOC = options.sumSLOC
    timestamp = options.timestamp
    verbose = options.verbose

    lines = 0
    sloc = 0

    options.already = set()  # an unordered collection, not a dictionary

    if projCfg and os.path.exists(projCfg):
        readFileMap(options.projCfg, namedFiles)

    configDir = os.path.join(os.environ['DVCZ_DIR'], 'config')
    stdFiles = os.path.join(configDir, 'projCfg')
    if stdFiles and os.path.exists(stdFiles):
        readFileMap(stdFiles, namedFiles)
    # DEBUG
    else:
        print("%s does not exist" % stdFiles)
    # END
    stdFilesForLang = os.path.join(configDir, 'projCfg.' + mainLang)
    if stdFilesForLang and os.path.exists(stdFilesForLang):
        readFileMap(stdFilesForLang, namedFiles)
    # DEBUG
    else:
        print("%s does not exist" % stdFilesForLang)
    # END

    # if a file is named on the command line, we always count it.
    for name in namedFiles:
        lang, isTest = None, False
        if (exRE is not None) and (exRE.search(name) is not None):
            if verbose > 1:
                print("skipping %s: excluded" % name)
            continue

        # DEBUG
        #print("CLI ARG IS FILE: '%s'" % name)
        # END

        # a file name may be prefixed with the short name of a language
        a, b, c = name.partition(':')
        if b == ':':
            lang, name = a, c

        if os.path.exists(name):
            l, s = 0, 0
            if os.path.isfile(name):
                counter = None
                if lang is None:
                    lang, isTest = q.guessLang('./', name,
                                               isCLIArg=True, verbose=options.verbose)
                if (lang is not None) and (lang in langsCounted):
                    counter = q.getCounter(lang, isCLIArg=True)
                if counter is None:
                    counter = countLinesNotSharp
                l, s = counter(name, options, lang)
                if lang == 'Rmd':
                    if isTest:
                        k.addTestCounts('R', l, s)
                    else:
                        k.addCounts('R', l, s)
                else:
                    if isTest:
                        k.addTestCounts(lang, l, s)
                    else:
                        k.addCounts(lang, l, s)

            elif os.path.isdir(name):
                # XXX EXCLUDE SOME DIRS
                l, s = countLinesInDir(name, options)
            else:
                print("? don't know how to count %s" % name)
            lines += l
            sloc += s
        else:
            print("file does not exist: %s" % name)

    # handle the current directory
    if not onlyNamedFiles:
        l, s = countLinesInDir('.', options)
        lines = lines + l
        sloc = sloc + s

    k.prettyBreakDown()
    print("total of %5d lines of code, of which %5d source" % (lines, sloc))


# MAIN ##############################################################
if __name__ == '__main__':

    # INTERPRET COMMAND LINE ----------------------------------------
    DESC = 'count lines of source code'
    parser = ArgumentParser(description=DESC)

    parser.add_argument('-C', '--langsCounted', nargs='?', const='all',
                        help='colon-separated list of langugages to be counted (abbrev)')
    parser.add_argument('-c', '--projCfg', default='.dvcz/projCfg.local',
                        help='file containing language/filename pairs')
    parser.add_argument('-j', '--justShow', action='store_true',
                        help='list options and exit')
    parser.add_argument('-L', '--mainLang', type=str,
                        help='main language expected (short name, optional)')
    parser.add_argument('-M', '--matches', type=str,
                        help='count ONLY files with matching names')
    parser.add_argument('-q', '--quiet', action='count', default=0,
                        help='be quiet (overrides -v if later')
    parser.add_argument('-S', '--sumSLOC', action='store_true',
                        help='total up SLOC counts')
    parser.add_argument('-t', '--showTimestamp', action='store_true',
                        help='output UTC timestamp to command line')
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help='make me more chatty')
    parser.add_argument('-V', '--showVersion', action='store_true',
                        help='show version information')
    parser.add_argument('-X', '--exclusions', action='append',
                        help='do not count files/directories with matching names')
    parser.add_argument('-z', '--onlyNamedFiles', action='store_true',
                        help='only count files named on the command line')

    parser.add_argument('namedFiles', nargs='*',
                        help='any number of namedFiles and/or directories to scan')
    args = parser.parse_args()

    args.k = K()   # a map, lang => (lines, sloc, tlines, tsloc)
    if args.mainLang:
        args.q = Q(args.mainLang)
    else:
        args.q = Q('')
    args.timestamp = "%04d%02d%02d-%02d%02d%02d" % time.gmtime()[:6]

    # fixups --------------------------------------------------------
    # assume that the exclusions are a list of globs ...
    args.exRE = makeExRE(args.exclusions)

    if args.quiet:
        args.verbose = 0

    if not args.mainLang:
        args.mainLang = ''

    if args.mainLang != '':
        if args.mainLang == 'octave':
            args.mainLang = 'matlab'
        h = args.q.getCounter(args.mainLang)
        if h is None:
            print("'%s' is not the short name of a supported language" %
                  args.mainLang)
            parser.print_help()
            sys.exit(1)

    langSet = args.q.getLangSet()    # names of all languages (abbrev)
    if not args.langsCounted or args.langsCounted == 'all':
        args.langsCounted = langSet
    else:
        langList = []
        selected = args.langsCounted.split(':')
        for x in selected:
            if x in langSet:
                langList.append(x)
            else:
                print("%s is not recognized as a language abbreviation", x)
                parser.print_usage()
                sys.exit(1)
        args.langsCounted = frozenset(langList)    # in place

    # sanity checks -------------------------------------------------

    # chatter -------------------------------------------------------
    if args.showVersion:
        print('pySloc v%s %s' % (__version__, __version_date__))
        sys.exit()
    if args.justShow or (args.verbose > 1):

        print("exclusions:      %s" % args.exclusions)
        print("mainLang:        %s (%s)" % (args.mainLang,
                                            args.q.getLongName(args.mainLang)))
        print("projCfg:         %s" % args.projCfg)
        print("langsCounted:    %s" % args.langsCounted)
        print("matches:         %s" % args.matches)
        print("onlyNamedFiles:  %s" % args.onlyNamedFiles)
        print("quiet:           %s" % args.quiet)
        print("showTimestamp:   %s" % args.showTimestamp)
        print("sumSLOC:         %s" % args.sumSLOC)
        print("timestamp:       %s" % args.timestamp)
        print("verbose:         %s" % args.verbose)
        print("version:         %s %s" % (__version__, __version_date__))

        if args.namedFiles:
            print("\nnamedFiles:")
            for file in args.namedFiles:
                print("    %s" % file)
            print()

    # do it ---------------------------------------------------------
    if not args.justShow:
        doCount(args)
