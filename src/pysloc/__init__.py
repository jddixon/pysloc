# pysloc/pysloc/__init__.py

""" Library for the pySloc line counter. """

import hashlib
import re
from stat import S_ISDIR, S_ISREG  # GETS DROPPED IF USING SCANDIR
import os
# try:
#    from os import scandir
# except ImportError:
#    from scandir import scandir


from bs4 import BeautifulSoup, Comment

__all__ = ['__version__', '__version_date__',
           # constants
           'GPERF_RE', 'RE2C_RE',
           # functions
           'count_lines_toml',                      # XXX TESTING IMPORT
           'count_lines_augeas',
           'count_lines_bash',
           'count_lines_c',
           'count_lines_clojure',
           'count_lines_clojurescript',
           'count_lines_cpp',
           'count_lines_double_dash',
           'count_lines_fortran',
           'count_lines_fortran90',
           'count_lines_gperf',
           'count_lines_go',
           'count_lines_html',
           'count_lines_in_dir',
           'count_lines_java',
           'count_lines_java_style',
           'count_lines_lisp',
           'count_lines_matlab',
           'count_lines_not_sharp',
           'count_lines_ocaml',
           'count_lines_occam',
           'count_lines_pascal',
           'count_lines_perl',
           'count_lines_protobuf',
           'count_lines_python',
           'count_lines_r_markdown',
           'count_lines_rust',
           'count_lines_re2c',
           'count_lines_ruby',
           'count_lines_scala', 'count_lines_shell', 'count_lines_snobol',
           'count_lines_tex',
           'count_lines_txt',
           'uncomment_html', 'uncomment_java',
           # classes
           'CountHolder', 'MapHolder', ]

# exported constants ------------------------------------------------
__version__ = '0.9.5'
__version_date__ = '2017-12-19'

# private constants -------------------------------------------------
GPERF_RE = re.compile(
    r'^/\* ANSI-C code produced by gperf version \d+\.\d\.\d+ \*/')
RE2C_RE = re.compile(r'^/\* Generated by re2c \d+\.\d+\.\d+ \*/')

TQUOTE = '"""'

# class(es) ---------------------------------------------------------


class CountHolder(object):
    """ a holder for various counts """

    LOC = 0   # lines of non-test code
    SLOC = 1   # of which source lines
    TLOC = 2   # lines of test code
    TSLOC = 3   # of which source lines

    def __init__(self):
        # we maintain map from lang to a list of 4: lines, sloc, tlines, tsloc,
        # where t means test
        self.map_ = {}

    def add_counts(self, lang, loc_, sloc_):
        """ add non-test line count and source line count for language"""

        # XXX we want l and s to be non-negative integers

        if lang not in self.map_:
            self.map_[lang] = [0, 0, 0, 0]
        self.map_[lang][CountHolder.LOC] += loc_
        self.map_[lang][CountHolder.SLOC] += sloc_

    def add_test_counts(self, lang, loc_, sloc_):
        """ add test line count and source line count for language"""

        # XXX we want l and s to be non-negative integers

        if lang not in self.map_:
            self.map_[lang] = [0, 0, 0, 0]
        self.map_[lang][CountHolder.TLOC] += loc_
        self.map_[lang][CountHolder.TSLOC] += sloc_

    def get_counts(self, lang):
        if (not lang) or (lang not in self.map_):
            return (0, 0, 0, 0)
        return self.map_[lang]

    def pretty_counts(self, lang):
        """
        Return a string containing the short name of the language and
        the total line count, the source line count, and the percentage
        of source lines which are test lines.  The total line count
        includes the source line count.  As an example a python file
        with 17 lines of which 12 are source, of which 9 are test code
        would produce the string 'py:17/12 T%75.0'

        """
        if (not lang) or (lang not in self.map_):
            return '%s: 0' % lang
        loc_, sloc_, test_loc, test_sloc = self.map_[lang]
        if test_sloc > 0:
            return "%s:%d/%d T%.1f%%" % (
                lang, loc_ + test_loc, sloc_ + test_sloc,
                100.0 * test_sloc / (sloc_ + test_sloc))
        elif loc_ > 0:
            return "%s:%d/%d" % (lang, loc_ + test_loc, sloc_)
        return ''

    def pretty_break_down(self):
        """
        Generate a semicolon-separated list sorted by decreasing SLOC.
        """

        # flatten the list to make it easier to sort
        flattened = []
        for k__, v__ in self.map_.items():
            flattened.append([k__] + v__)
        results = []
        for x__ in sorted(flattened, key=lambda fields: fields[
                CountHolder.SLOC + 1], reverse=True):
            result = self.pretty_counts(x__[0])
            if result:
                results.append(result)
        print('; '.join(results))

    def get_totals(self):
        tot_loc, tot_sloc, tot_test_loc, tot_test_sloc = 0, 0, 0, 0
        for lang in self.map_:
            loc_, sloc_, test_loc, test_sloc = self.map_[lang]
            tot_loc += loc_    # lines of non-test code
            tot_sloc += sloc_    # lines of which are source code
            tot_test_loc += test_loc   # lines of test code
            tot_test_sloc += test_sloc   # lines of which are source code
        return tot_loc, tot_sloc, tot_test_loc, tot_test_sloc


class MapHolder(object):

    def __init__(self, main_lang=''):

        # Note OCaml comments are (* ... *) but allow nesting.  File
        # extensions are .ml (source code) and .mli (header; and then
        # .cmo/.cmx, .cmi, .cma/.cmxa are compiled forms.

        # Maps short name to counter function; limit these to 4 characters.
        self._lang2counter = {
            'ada': count_lines_double_dash,     # Pentagon language
            'asm': count_lines_not_sharp,       # s, S, asm
            'awk': count_lines_not_sharp,       # awk programming language
            'aug': count_lines_augeas,          # Augeas config manager
            'bash': count_lines_shell,          # bash shell
            'c': count_lines_c,                 # ansic
            'clj': count_lines_clojure,         # Clojure
            'cljs': count_lines_clojurescript,  # ClojureScript
            'code': count_lines_not_sharp,      # used to be 'not#'
            'cpp': count_lines_cpp,             # C++
            'csh': count_lines_not_sharp,       # csh, tcsh
            'css': count_lines_java_style,      # css, as in stylesheets
            'cython': count_lines_python,
            'f90+': count_lines_fortran90,      # FORTRAN90 plus
            'for': count_lines_fortran,         # fixed-format FORTRAN
            'gen': count_lines_not_sharp,       # treat # as comment
            'go': count_lines_go,               # golang
            'gperf': count_lines_gperf,         #
            'hs': count_lines_double_dash,      # Haskell
            'html': count_lines_html,           # html
            'java': count_lines_java,           # plain old Java
            'js': count_lines_java_style,       # Javascript
            'json': count_lines_txt,            # json
            'lex': count_lines_java_style,      # lex/flex
            'lisp': count_lines_lisp,           # Common Lisp
            'm4': count_lines_not_sharp,        # m4 macro processor
            'ml': count_lines_ocaml,            # ocaml, tentative abbrev
            'objc': count_lines_java_style,     # Objective C
            'occ': count_lines_double_dash,     # concurrent programming
            'perl': count_lines_perl,
            'proto': count_lines_protobuf,      # Google Protocol Buffers
            'py': count_lines_python,           # yes, Python
            'R': count_lines_not_sharp,         # R
            'Rmd': count_lines_r_markdown,
            're2c': count_lines_re2c,           # re2c
            'rb': count_lines_ruby,             # ruby
            'rs': count_lines_rust,             # rust
            'scala': count_lines_scala,
            'sed': count_lines_not_sharp,       # stream editor
            'sh': count_lines_shell,            # shell script
            'sno': count_lines_snobol,          # snobol4
            'tcl': count_lines_not_sharp,       # tcl, tk, itk
            'tex': count_lines_tex,             # TeX, LaTeX
            'toml': count_lines_not_sharp,      # Tom's Obvious Markup Language
            'txt': count_lines_txt,             # plain text
            'xml': count_lines_xml,
            'yacc': count_lines_java_style,     # yacc, bison
            'yaml': count_lines_not_sharp,      # yaml
        }
        # Guesses language short name (abbrev) from file extension.
        # See sloccount's break_filelist for hints.
        # Note {pl,pm,perl,pl} => perl
        self._ext2lang = {
            'adb': 'ada',
            'ads': 'ada',
            'asm': 'asm',
            'aug': 'augeas',
            'awk': 'awk',
            'bash': 'bash',                 # yes, never used
            'c': 'c',                       # ansi c
            'C': 'cpp',                     # C++
            'cc': 'cpp',                    # C++
            'clj': 'clj',                   # Clojure
            'cljs': 'cljs',                 # ClojsureScript
            'code': 'code',                 # comments begin with sharp sign, #
            'cp': 'cpp',                    # C++
            'cpp': 'cpp',                   # C++
            'CPP': 'cpp',                   # C++
            'c++': 'cpp',                   # C++
            'cxx': 'cpp',                   # C++
            'csh': 'csh',
            'css': 'css',
            'flattened': 'for',             # fixed-format FORTRAN
            'f90': 'f90+',                  # free-format FORTRAN
            'f95': 'f90+',                  # free-format FORTRAN
            'f03': 'f90+',                  # free-format FORTRAN
            'f08': 'f90+',                  # free-format FORTRAN
            'f15': 'f90+',                  # free-format FORTRAN
            'for': 'for',
            'go': 'go',                     # same counter as C, Java ?
            'gperf': 'gperf',               # same counter as C, Java ?
            'h': 'c',                       # PRESUMED ANSI C
            'hh': 'cpp',                    # C++; I've never seen this
            'hpp': 'cpp',                   # C++
            'hs': 'hs',                     # Haskell
            'html': 'html',                 # no counter
            'itk': 'tcl',
            'java': 'java',
            'js': 'js',                     # javascript, node.js
            'json': 'json',
            'l': 'lex',                     # lex/flex parser generator
            'lisp': 'lisp',
            'loc_': 'lex',                  # lex/flex parser generator
            'm4': 'm4',                     # no counter
            'md': 'md',                     # no counter
            'ml': 'ml',                     # OCaml
            'mli': 'ml',                    # OCaml extension
            'occ': 'occ',
            'pl': 'perl',
            'pm': 'perl',
            'proto': 'proto',                  # Google protobuf
            'pxd': 'cython',                # cython header
            'py': 'py',
            'pyx': 'cython',                # cython code
            'R': 'R',                      # R programming language
            'r': 'R',                      # R programming language
            'Rmd': 'Rmd',                    # RMarkdown
            'rb': 'rb',
            're': 're2c',                   # same counter as C, Java ?
            'rs': 'rs',                     # rust, comments start with //
            'S': 'asm',
            'sloc_': 'asm',
            'scala': 'scala',
            'sed': 'sed',
            'sh': 'sh',
            'sno': 'sno',
            'tcsh': 'csh',
            'tcl': 'tcl',
            'tex': 'tex',
            'tk': 'tcl',
            'toml': 'toml',
            'txt': 'txt',
            'xml': 'xml',
            'y': 'yacc',                   # parser generator
            'yaml': 'yaml',
        }
        # DEBUG
        assert self._ext2lang['yaml'] == 'yaml'
        assert self._ext2lang['toml'] == 'toml'
        # END
        if main_lang == 'c':
            self._ext2lang['inc'] = 'c'
        if main_lang == 'cpp':
            self._ext2lang['h'] = 'cpp'
            self._ext2lang['inc'] = 'cpp'
        elif main_lang == 'matlab':
            self._ext2lang['map_'] = 'matlab'
        elif main_lang == 'objc':
            self._ext2lang['h'] = 'objc'
            self._ext2lang['map_'] = 'objc'
        elif main_lang == 'occ':
            self._ext2lang['inc'] = 'occ'
        elif main_lang == 'octave':
            self._ext2lang['map_'] = 'octave'

        # Maps lang short name (abbrev) to fuller language name.
        # By convention, short names are limited to 5 chars.
        self._lang_map = {
            'ada': 'Ada',
            'asm': 'assembler',
            'aug': 'augeas',
            'awk': 'awk',
            'bash': 'bash',
            'c': 'ansic',
            'clj': 'Clojure',
            'cljs': 'ClojureScript',
            'code': 'code',                     # the former 'not#'
            'cpp': 'C++',
            'csh': 'csh',
            'css': 'css',
            'cython': 'cython',
            'f90+': 'FORTRAN90+',
            'for': 'FORTRAN',
            'gen': 'generic',
            'gperf': 'gperf',
            'go': 'golang',
            'hs': 'haskell',
            'html': 'html',
            'java': 'java',
            'js': 'javascript',
            'json': 'json',
            'lex': 'lex',
            'lisp': 'lisp',
            'm4': 'm4',
            'md': 'markdown',
            'ml': 'OCaml',
            'objc': 'Objective C',
            'occ': 'Occam',
            'perl': 'Perl',
            'proto': 'proto',                  # Google protobuf
            'py': 'python',
            'R': 'R',
            'Rmd': 'R Markdown',
            're2c': 're2c',
            'rb': 'ruby',
            'rs': 'rust',
            'scala': 'scala',
            'sed': 'sed',
            'sh': 'shell',
            'sno': 'snobol4',
            'tcl': 'tcl',
            'tex': 'TeX/LaTeX',
            'toml': 'toml',
            'txt': 'text',
            'xml': 'XML',
            'yacc': 'yacc',
            'yaml': 'yaml',
        }

        # A set of extensions known NOT to be source code.
        self._non_code_exts = {
            'lang_',                                # library, linked object
            'cma', 'cmi', 'cmo', 'cmx', 'cmxa',     # OCaml compiled
            # 'dat',                                # arguable
            'gz',
            'jar',
            'md',                                   # markdown
            'o',                                    # object
            'pyc', 'pyo',
            'so',
            'svn-base',
            'swp',                                  # vi/vim temporary file
            'zip',
        }
        # A set of file and directory names known NOT to contain source code
        self._non_code_dirs = {
            '.git',
            '__pycache__',
            '.svn',
        }
        # files which definitely do not contain source code
        self._non_code_files = {
            '.gitignore',
            '.wrapped',
            'AUTHORS',
            'CHANGES', 'ChangeLog',
            'CONTRIBUTORS',
            'COPYING', 'COPYING.AUTOCONF.EXCEPTION',
            'COPYING.GNUBL', 'COPYING.LIB',
            'LICENSE',
            'MANIFEST',
            'NEWS',
            'PATENTS',
            'README',
            'TODO',
        }

    # public interface ==============================================

    def ext2lang(self, ext):
        if ext in self._ext2lang:
            return self._ext2lang[ext]
        return None

    def get_counter(self, lang, is_cli_arg=False):
        """
        Enter with the language (abbrev) of a file and whether the name is on
        the command line.  If there is a counter matching that name, return a
        reference to it.  Otherwise, if this is a CLI argument, return the
        generic counter.  Otherwise, return None.

        XXX If the name on the command line is a directory name, should
        be handled differently.
        """
        if lang and (lang in self._lang2counter):
            return self._lang2counter[lang]
        elif is_cli_arg:
            return count_lines_not_sharp
        return None

    def get_long_name(self, name):
        """ Given a short file name, return the longer language name """
        if name in self._lang_map:
            return self._lang_map[name]
        return None

    def get_lang_set(self):
        "Return a set containing all recognized language abbreviations"""
        return frozenset(self._lang_map.keys())

    def non_code_ext(self, name):
        return name in self._non_code_exts

    def non_code_dir(self, name):
        return name in self._non_code_dirs

    def non_code_file(self, name):
        return name in self._non_code_files

    def guess_lang(self, path_to_dir, file_name, is_cli_arg, verbose=0):
        """
        Guess the short name of the language and whether it is a test file
        depending on whether the name appears on the command line (we
        always count any file named on the command line).
        """

        # defaults
        is_test = False
        lang = None
        ext = None

        if path_to_dir and file_name:
            path_to_file = os.path.join(path_to_dir, file_name)
            if os.path.exists(path_to_file):

                if not self.non_code_file(file_name):
                    # get any extension
                    _, delim, ext = file_name.rpartition('.')
                    if delim == '.':
                        # we have an extension
                        ext = ext
                        if not self.non_code_ext(ext):
                            # we have an extension and it's not prohibited
                            lang = self.ext2lang(ext)
                            if (lang is None) and is_cli_arg:
                                lang = 'gen'            # generic
                    if not lang and is_cli_arg:
                        lang = 'gen'

                if lang == 'go':
                    is_test = file_name.endswith('_test.go')
                elif lang == 'py':
                    is_test = file_name.startswith('test')

                # filter out generated files
                if lang and lang != 'gen':
                    if self.is_generated(path_to_file, verbose):
                        return None, False

                if verbose > 1:
                    if ext is not None:
                        print("  %s: find ext '%s', GUESS lang %s" % (
                            file_name, ext, lang))

                    else:
                        print(
                            "  %s: NO ext, GUESS lang %s" %
                            (file_name, lang))

        # DEBUG
        # print("guessLang: fileName %s, isCLIArg %s;\treturning lang %s, " +
        #       "isTest %s" % (
        #    fileName, isCLIArg, lang, isTest))
        # END

        return lang, is_test

    def is_generated(self, path_to_file, verbose=0):
        first_line = ''
        try:
            with open(path_to_file, 'r') as flattened:
                first_line = flattened.readline()
        except Exception as exc:
            print("problem reading '%s': %s" % (path_to_file, exc))
            return False

        for regex in [GPERF_RE, RE2C_RE]:
            if regex.match(first_line):
                return True

        return False

# functions =========================================================

# DIR-LEVEL COUNTER(S) ----------------------------------------------


def count_lines_in_dir(path_to_dir, options):
    # DEBUG
    # print("DIRECTORY %s" % pathToDir)
    # if not options:
    #    print("  NIL OPTIONS")
    # else:
    #    for pair in options._get_kwargs():
    #        ls = pair[0]
    #        rs = pair[1]
    #        print("%s => %s" % (ls, rs))
    # END
    k__ = options.k__
    langs_counted = options.langs_counted
    # DEBUG
    # print("LANGS COUNTED: %s" % langsCounted)
    # END
    map_holder = options.map_holder
    verbose = options.verbose
    lines, sloc = (0, 0)
    files = os.listdir(path_to_dir)
    if files:
        map_holder = options.map_holder
        for name in sorted(files):
            # we only count *.txt if on the command line
            if name.endswith('.txt'):
                continue
            # consider exclusions ...
            if options.ex_re is not None and options.ex_re.search(
                    name) is not None:
                # DEBUG
                # print("EXCLUDED: %s" % name)
                # END
                continue
            # DEBUG
            # print("FILE IN DIRECTORY: %s" % name)
            # END
            is_test = False  # default
            path_to_file = os.path.join(path_to_dir, name)
            sloc_ = os.lstat(path_to_file)        # ignores symlinks
            mode = sloc_.st_mode
            if S_ISDIR(mode):
                (more_lines, more_sloc) = count_lines_in_dir(
                    path_to_file, options)
                lines += more_lines
                sloc += more_sloc
            elif S_ISREG(mode):
                if map_holder.non_code_file(name):
                    if verbose > 1:
                        print("Not a code file: %s" % name)
                else:
                    # XXX Note command line argument may be relative or
                    # absolute path to file, terminated by base file name
                    # and extension.
                    counted = False
                    lang, is_test = map_holder.guess_lang(
                        path_to_dir, name, is_cli_arg=False, verbose=verbose)
                    if (lang is not None) and (lang in langs_counted):
                        counter = map_holder.get_counter(lang, True)
                        if counter:
                            more_lines, more_sloc = counter(
                                path_to_file, options, lang)
                            lines += more_lines  # VESTIGIAL
                            sloc += more_sloc

                            if is_test:
                                k__.add_test_counts(
                                    lang, more_lines, more_sloc)
                            else:
                                k__.add_counts(lang, more_lines, more_sloc)
                            counted = True

                    if not counted and options.verbose >= 2:
                        print("    skipping %s" % name)

    return lines, sloc

# FILE-LEVEL COUNTERS -----------------------------------------------


def check_whether_already_counted(path_to_file, options):
    """
    Given a text file, try to split it into a list of lines.  May raise
    an exception.  If the file has been seen before, will return an
    empty list of lines.  Otherwise it retuns the list of lines and the
    file's hash.

    options.already is a set containing hashes of files already counted
    """
    lines, counter_ = None, None
    with open(path_to_file, 'rb') as flattened:
        data = flattened.read()
    if data:
        sha_ = hashlib.sha1()
        sha_.update(data)
        counter_ = sha_.hexdigest()   # a string
        if options.verbose > 1:
            print("    %s <-- %s" % (counter_, path_to_file))
        if counter_ in options.already:
            if options.verbose:
                print("skipping %s, already counted" % path_to_file)
        else:
            try:
                decoded = data.decode('utf-8')
            except Exception:
                decoded = data.decode('latin-1')
            lines = decoded.split("\n")

            # drop spurious last line caused by terminating newline
            if lines and len(lines) > 1:
                if lines[-1] == '':
                    lines = lines[:-1]
    return lines, counter_

# TOML ==============================================================
# XXX SHOULD BE IN ALPHABETICAL ORDER, up here for debugging


def count_lines_toml(path_to_file, options, lang):
    """ Count lines in a file with extension '.toml'. """

# AUGEAS ============================================================


def count_lines_augeas(path, options, lang):
    return count_lines_ocaml(path, options, lang)

# BASH ==============================================================


def count_lines_bash(path, options, lang):
    return count_lines_shell(path, options, lang)

# C =================================================================


def count_lines_c(path, options, lang):
    loc_, sloc_ = 0, 0

    if path.endswith('.h'):
        if not path.endswith('.pb-c.h'):
            loc_, sloc_ = count_lines_java_style(path, options, lang)
    elif path.endswith('.c'):
        if not path.endswith('.pb-c.c'):
            loc_, sloc_ = count_lines_java_style(path, options, lang)

    return loc_, sloc_

# CLOJURE, CLOJURE_SCRIPT ===========================================


def count_lines_clojure(path_to_file, options, lang):
    return count_lines_not_semicolon(path_to_file, options, lang)


def count_lines_clojurescript(path_to_file, options, lang):
    return count_lines_not_semicolon(path_to_file, options, lang)

# C++ ===============================================================


def count_lines_cpp(path, options, lang):
    # DEBUG
    print("count_lines_cpp() checking path '%s', lang '%s'" % (path, lang))
    # END
    loc_, sloc_ = 0, 0
    if path.endswith('.h'):
        if not path.endswith('.pb.h'):
            loc_, sloc_ = count_lines_java_style(path, options, lang)
    elif path.endswith('.cpp'):
        if not path.endswith('.pb.cpp'):
            loc_, sloc_ = count_lines_java_style(path, options, lang)
    else:
        loc_, sloc_ = count_lines_java_style(path, options, lang)

    return loc_, sloc_

# FORTRAN ===========================================================


def count_lines_fortran(path_to_file, options, lang):

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1

                line_len = len(line)
                if line_len:
                    if line[0] in ['c', 'C']:
                        # a comment
                        continue

                    # code area is columns 7-72, 1-based, so 6-71
                    if line[0].lower() == 'c' or line_len < 7:
                        continue
                    if line_len > 72:
                        line = line[6:72]
                    else:
                        line = line[6:]
                    for ch_ in line:
                        if ch_ != ' ':
                            sloc_so_far += 1
                            break

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))

    return lines_so_far, sloc_so_far

# FORTRAN 90+ =======================================================


def count_lines_fortran90(path_to_file, options, lang):
    """
    Count lines of free-format FORTRAN 90+
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1

                line_len = len(line)
                if line_len:
                    # DEBUG
                    # print("\nLINE: '%s'" % line)
                    # END
                    if line[0] in ['c', 'C']:
                        # a fixed-form comment
                        continue

                    # a BANG ('!') anywhere begins a comment
                    ndx = line.find('!')
                    if ndx != -1:
                        line = line[0:ndx]
                        line_len = len(line)
                        if line_len == 0:
                            continue

                    # code area is columns 7-72, 1-based, so 6-71
                    if line[0].lower() == 'c' or line_len < 7:
                        continue
                    if line_len > 72:
                        line = line[6:72]
                    else:
                        line = line[6:]
                    for ch_ in line:
                        if ch_ != ' ':
                            sloc_so_far += 1
                            # DEBUG
                            # print("  SLOC %02d: '%s'" % (sloc_so_far, line))
                            # END
                            break

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))

    return lines_so_far, sloc_so_far

# GO ================================================================


def count_lines_go(path_to_file, options, lang):
    lines_so_far, sloc_so_far = (0, 0)
    if not path_to_file.endswith('.pb.go'):
        lines_so_far, sloc_so_far = count_lines_java_style(
            path_to_file, options, lang)
    return lines_so_far, sloc_so_far

# GPERF ==============================================================


def count_lines_gperf(path, options, lang):
    loc_, sloc_ = count_lines_java_style(path, options, lang)
    return loc_, sloc_

# HTML ==============================================================


def _find_html_code(text):
    """
    We are in a comment.  Return a ref to the beginning of the text
    outside the comment block (which may be '') and the value of inComment.
    """
    posn = text.find('-->')
    if posn == -1:
        return '', True

    if posn + 3 < len(text):
        return text[posn + 3:], False
    return '', False


def _find_html_comment(text):
    """
    We are NOT in a comment.  Return a ref to any code found, a ref to the
    rest of the text, and the value of inComment.
    """
    posn = text.find('<!--')       # one-line comment

    if posn == -1:
        return text, '', False

    if posn + 4 < len(text):
        return text[:posn], text[posn + 4:], True
    return text[:posn], '', True


def uncomment_html(text, in_comment):
    """
    Given a line of text, return a ref to any code found and the value of
    inComment, which may have changed.
    """
    code = ''
    text = text.strip()
    while text:
        if in_comment:
            text, in_comment = _find_html_code(text)
        else:
            chunk, text, in_comment = _find_html_comment(text.strip())
            code += chunk   # XXX INEFFICIENT

    return code, in_comment

# A better definition of a comment is that it begins with <!-- and ends
# with --> but does not contain -- or >


def count_lines_html(path_to_file, options, lang):
    lines_so_far, sloc_so_far = (0, 0)
    in_comment = False
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1

                code, in_comment = uncomment_html(line, in_comment)
                if code:
                    code = code.strip()
                    if code:
                        sloc_so_far += 1

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))

    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return (lines_so_far, sloc_so_far)

# JAVA ==============================================================


def count_lines_java(path_to_file, options, lang):
    lines_so_far, sloc_so_far = (0, 0)
    if not path_to_file.endswith('Protos.java'):
        lines_so_far, sloc_so_far = count_lines_java_style(
            path_to_file, options, lang)
    return lines_so_far, sloc_so_far


def _find_java_code(text):
    """
    We are in a comment.  Return a ref to the beginning of the text
    outside the comment block (which may be '') and the value of inComment.
    """
    posn = text.find('*/')
    if posn == -1:
        return '', True

    if posn + 2 < len(text):
        return text[posn + 2:], False
    return '', False


def _find_java_comment(text):
    """
    We are NOT in a comment.  Return a ref to any code found, a ref to the
    rest of the text, and the value of inComment.
    """
    multi_line = False
    posn_old = text.find('/*')       # multi-line comment
    posn_new = text.find('//')       # one-line comment

    if posn_old == -1 and posn_new == -1:
        return text, '', False

    if posn_new == -1:
        posn = posn_old
        in_comment = True
        multi_line = True
    else:
        # posnNew is non-negative
        if posn_old == -1 or posn_old > posn_new:
            posn = posn_new
            in_comment = False
        else:
            posn = posn_old
            in_comment = True
            multi_line = True

    if multi_line and (posn + 2 < len(text)):
        return text[:posn], text[posn + 2:], in_comment
    return text[:posn], '', in_comment


def uncomment_java(text, in_comment):
    """
    Given a line of text, return a ref to any code found and the value of
    inComment, which may have changed.
    """
    code = ''
    text = text.strip()
    while text:
        if in_comment:
            text, in_comment = _find_java_code(text)
        else:
            chunk, text, in_comment = _find_java_comment(text.strip())
            code += chunk   # XXX INEFFICIENT

    return code, in_comment


def count_lines_java_style(path_to_file, options, lang):
    lines_so_far, sloc_so_far = (0, 0)
    in_comment = False
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1

                code, in_comment = uncomment_java(line, in_comment)
                if code:
                    code = code.strip()
                    if code:
                        sloc_so_far += 1

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))

    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return (lines_so_far, sloc_so_far)

# Lisp ==============================================================


def count_lines_lisp(path_to_file, options, lang):
    return count_lines_not_semicolon(path_to_file, options, lang)

# MATLAB ============================================================


def count_lines_matlab(path_to_file, options, lang):
    """
    Count source lines in an Matlab file where single line comments
    begin with '%' and muli-line comments are delimited by
    %{ and %}.  These may be nested.  We ignore blank lines and lines
    consisting solely of spaces and comments.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            depth = 0                           # comment depth
            # for l_ndx, line in enumerate(lines):
            for line in lines:
                lines_so_far += 1
                non_space_sen = False
                percent_sen = False             # might start %{ or %}
                # for c_ndx, ch_ in enumerate(list(line)):
                for ch_ in list(line):
                    # DEBUG
                    # print("line %2d char %2d '%c' depth %2d percent? " +
                    #       "%s nonSpace? %s" % (
                    #        lNdx, cNdx, ch, depth, percentSeen, nonSpaceSeen))
                    # END
                    if percent_sen:
                        if ch_ == '{':
                            depth += 1
                        elif ch_ == '}':
                            if depth > 0:
                                depth -= 1
                        else:
                            # this would start a comment
                            if depth == 0:
                                break
                        percent_sen = False

                    elif depth == 0:
                        if ch_ == '%':
                            percent_sen = True
                        elif ch_ != ' ' and ch_ != '\t':
                            non_space_sen = True
                            # ignore other unicode space chars for now
                        else:
                            pass

                    else:
                        # depth > 0
                        if percent_sen:
                            if ch_ == '{':
                                depth += 1
                            elif ch_ == '}':
                                depth -= 1
                            percent_sen = False
                        elif ch_ == '%':
                            percent_sen = True

                if non_space_sen:
                    sloc_so_far += 1

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# NOT_SHARP =========================================================


def count_lines_not_sharp(path_to_file, options, lang):
    """
    Count lines in a file where the sharp sign ('#') is the comment
    marker.  That is, we ignore blank lines, lines consisting solely of
    spaces, and those starting with zero or more spaces followed by
    a sharp sign.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1
                # This could be made more efficient.
                line = line.strip()
                if line and (line[0] != '#'):
                    sloc_so_far += 1
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# OCaml =============================================================


def count_lines_ocaml(path_to_file, options, lang):
    """
    Count lines in an OCaml file where comments are delimited by
    (* and *).  These may be nested.  We ignore blank lines and lines
    consisting solely of spaces and comments.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            depth = 0                           # comment depth
            for line in lines:
                lines_so_far += 1
                non_space_sen = False
                l_paren_sen = False            # might start (*
                star_seen = False            # might start *)
                for ch_ in list(line):
                    # ignore other unicode space chars for now
                    if ch_ == ' ' or ch_ == '\t':
                        l_paren_sen = False
                        star_seen = False
                        continue
                    elif depth == 0:
                        if l_paren_sen:
                            if ch_ == '*':
                                depth += 1
                            else:
                                non_space_sen = True
                            l_paren_sen = False
                        elif star_seen:
                            if ch_ == ')':
                                if depth > 0:
                                    depth -= 1
                                else:
                                    non_space_sen = True
                                star_seen = False
                            else:
                                non_space_sen = True
                        elif ch_ == '(':
                            l_paren_sen = True
                        elif ch_ == '*':
                            star_seen = True
                        else:
                            non_space_sen = True
                    else:
                        # depth > 0
                        if l_paren_sen:
                            if ch_ == '*':
                                depth += 1
                            l_paren_sen = False
                        elif star_seen:
                            if ch_ == ')':
                                if depth > 0:
                                    depth -= 1
                                star_seen = False
                        elif ch_ == '(':
                            l_paren_sen = True
                        elif ch_ == '*':
                            star_seen = True

                if non_space_sen:
                    sloc_so_far += 1

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# OCCAM =============================================================


def count_lines_double_dash(path_to_file, options, lang):
    """
    Count lines in a file where the double dash ('--') is the comment
    marker.  That is, we ignore blank lines, lines consisting solely of
    spaces, and those starting with zero or more spaces followed by
    a double dash.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1
                # This could be made more efficient.
                line = line.strip()
                if line and not line.startswith('--'):
                    sloc_so_far += 1
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# OCCAM =============================================================


def count_lines_occam(path_to_file, options, lang):
    """
    Count source lines in an Octave file where single line comments
    begin with '%' or '#' and multi-line comments are delimited by
    %{ and %} or #{ and #}. These may be nested.  We ignore blank lines
    and lines consisting solely of spaces and comments.

    NOTE that Octave actually requires that a multi-line comment marker
    be the only token on the source line.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            depth = 0                           # comment depth
            # for l_ndx, line in enumerate(lines):
            for line in lines:
                lines_so_far += 1
                non_space_sen = False
                delim_seen = False             # might start %{ or %}
                # for c_ndx, ch_ in enumerate(list(line)):
                for ch_ in list(line):
                    # DEBUG
                    # print("line %2d char %2d '%c' depth %2d percent? " +
                    #       "%s nonSpace? %s" % (
                    #        lNdx, cNdx, ch, depth, delimSeen, nonSpaceSeen))
                    # END
                    if delim_seen:
                        if ch_ == '{':
                            depth += 1
                        elif ch_ == '}':
                            if depth > 0:
                                depth -= 1
                        else:
                            # this would start a comment
                            if depth == 0:
                                break
                        delim_seen = False

                    elif depth == 0:
                        if ch_ == '%' or ch_ == '#':
                            delim_seen = True
                        elif ch_ != ' ' and ch_ != '\t':
                            non_space_sen = True
                            # ignore other unicode space chars for now
                        else:
                            pass

                    else:
                        # depth > 0
                        if delim_seen:
                            if ch_ == '{':
                                depth += 1
                            elif ch_ == '}':
                                depth -= 1
                            delim_seen = False
                        elif ch_ == '%' or ch_ == '#':
                            delim_seen = True

                if non_space_sen:
                    sloc_so_far += 1

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# PASCAL ============================================================


def count_lines_pascal(path_to_file, options, lang):
    """
    Count lines in an Pascal file where comments are delimited by
    (* and *) or { and } -- interchangeably.  These may be nested.  We
    ignore blank lines and lines consisting solely of spaces and comments.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            depth = 0                           # comment depth
            # for ndx, line in enumerate(lines):
            for line in lines:
                lines_so_far += 1
                non_space_sen = False
                l_paren_sen = False            # might start (*
                star_seen = False            # might start *)
                for ch_ in list(line):
                    # ignore other unicode space chars for now
                    if ch_ == ' ' or ch_ == '\t':
                        l_paren_sen = False
                        star_seen = False
                        continue
                    elif depth == 0:
                        if l_paren_sen:
                            if ch_ == '}':
                                non_space_sen = True
                            elif ch_ == '*' or ch_ == '{':
                                depth += 1
                            else:
                                non_space_sen = True
                            l_paren_sen = False
                        elif star_seen:
                            if ch_ == '{':
                                depth += 1
                            elif ch_ == ')' or ch_ == '}':
                                non_space_sen = True
                                star_seen = False
                            else:
                                non_space_sen = True
                        elif ch_ == '{':
                            depth += 1
                        elif ch_ == '}':
                            pass
                        elif ch_ == '(':
                            l_paren_sen = True
                        elif ch_ == '*':
                            star_seen = True
                        else:
                            non_space_sen = True
                    else:
                        # depth > 0
                        if l_paren_sen:
                            if ch_ == '}':
                                if depth > 0:
                                    depth -= 1
                            elif ch_ == '*' or ch_ == '{':
                                depth += 1
                            l_paren_sen = False
                        elif star_seen:
                            if ch_ == '{':
                                depth += 1
                            elif ch_ == '}':
                                depth -= 1
                            elif ch_ == ')':
                                if depth > 0:
                                    depth -= 1
                                star_seen = False
                        elif ch_ == '{':
                            depth += 1
                        elif ch_ == '}':
                            depth -= 1
                        elif ch_ == '(':
                            l_paren_sen = True
                        elif ch_ == '*':
                            star_seen = True

                if non_space_sen:
                    sloc_so_far += 1

                # DEBUG
                # print("line %3d depth %2d slocSeen %3d: '%s'" % (
                #    ndx, depth, slocSoFar, line))
                # END

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# PERCENT ===========================================================


def count_lines_not_percent(path_to_file, options, lang):
    """
    Count lines in a file where the percent sign ('%') is the comment
    marker.  That is, we ignore blank lines, lines consisting solely of
    spaces, and those starting with zero or more spaces followed by
    a percent sign.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1
                # This could be made more efficient.
                line = line.strip()
                if line and (line[0] != '%'):
                    sloc_so_far += 1
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# PERL ==============================================================


def count_lines_perl(path_to_file, options, lang):
    """
    XXX REWRITE:

    Count lines in a file where the sharp sign ('#') is the comment
    marker.  That is, we ignore blank lines, lines consisting solely of
    spaces, and those starting with zero or more spaces followed by
    a sharp sign.

    XXX EXPAND THIS TO HANDLE POD BLOCKS, treated as multi-line comments.

    """

    lines_so_far, sloc_so_far = (0, 0)
    in_pod = False
    in_for = False
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1

                if in_pod:
                    if line == '=cut':
                        in_pod = False
                    continue
                if in_for:
                    if line == '=cut':
                        in_for = False
                    continue
                if line == '=pod':
                    in_pod = True
                    continue
                if line.startswith('=for comment'):
                    in_for = True
                    continue

                # This could be made more efficient.
                line = line.strip()
                if line and (line[0] != '#'):
                    sloc_so_far += 1
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# PROTOBUF ==========================================================


def count_lines_protobuf(path, options, lang):
    loc_, sloc_ = count_lines_java_style(path, options, lang)
    return loc_, sloc_

# PYTHON ============================================================


def count_lines_python(path_to_file, options, lang):
    lines_so_far, sloc_so_far = (0, 0)
    if not path_to_file.endswith('_pb2.py'):
        lines_so_far, sloc_so_far = _count_lines_python(
            path_to_file, options, lang)
    return lines_so_far, sloc_so_far


def _count_lines_python(path_to_file, options, lang):
    in_triple_quote = False
    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (lines is not None) and (hash_val is not None):
            for line in lines:
                if in_triple_quote:
                    # we always count this line
                    lines_so_far += 1
                    sloc_so_far += 1
                    count = line.count(TQUOTE)
                    if count % 2:
                        in_triple_quote = False
                else:
                    lines_so_far += 1
                    sloc_ = line.partition('#')[0]  # strip off comments
                    line = sloc_.strip()            # strip leading & trailing
                    if line != '':
                        sloc_so_far += 1
                    count = line.count(TQUOTE)
                    if count % 2:
                        in_triple_quote = True
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return (lines_so_far, sloc_so_far)

# RE2C ==============================================================


def count_lines_re2c(path, options, lang):
    loc_, sloc_ = count_lines_java_style(path, options, lang)
    return loc_, sloc_

# R MARKDOWN ========================================================


def count_lines_r_markdown(path_to_file, options, lang):
    """
    Count the lines of R in an RMarkdown file.  Count lines in
    (a) the YAML section at the top of the file, (b) chunks of R code
    following the normal rules (we ignore blank lines and anything
    following a sharp sign (#), and (c) wherever there is inline R
    code, we count that line as source code.

    To be counted, the YAML must begin at the very first line in the
    file and must be delimited by "^---" lines.

    This code only counts RMarkdown sections beginning with "```{r " and
    ending with "```".   That is, these must begin the line in each case.
    Also, anything beginning with "`r " is counted as an line variable.

    """

    # NOT YET AMENDED

    lines_so_far, sloc_so_far = (0, 0)
    in_code_chunk = False
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            in_yaml = False
            for ndx, line in enumerate(lines):
                lines_so_far += 1
                line = line.strip()

                # count YAML header if present ----------------------
                if ndx == 0 and line.startswith('---'):
                    in_yaml = True
                if in_yaml:
                    # DEBUG
                    # print("YAML: '%s'" % line)
                    # END
                    if line:
                        sloc_so_far += 1
                    if ndx and line.startswith('---'):
                        in_yaml = False
                        # already counted
                        # DEBUG
                        # print('total of %d lines of YAML' % slocSoFar)
                        # END
                    continue

                if in_code_chunk:
                    # DEBUG
                    # print("CODE: %s" % line)
                    # END
                    if line and (line[0] != '#'):
                        sloc_so_far += 1
                    if line.startswith('```'):
                        in_code_chunk = False
                        # already counted

                else:
                    # DEBUG
                    # print("TEXT: %s" % line)
                    # END
                    if line.startswith('```{r '):
                        sloc_so_far += 1
                        in_code_chunk = True
                        continue
                    if line.find('`r ') != -1:
                        sloc_so_far += 1

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# RUBY ==============================================================


def count_lines_ruby(path_to_file, options, lang):
    lines_so_far, sloc_so_far = (0, 0)
    if not path_to_file.endswith('.pb.rb'):
        lines_so_far, sloc_so_far = count_lines_not_sharp(
            path_to_file, options, lang)
    return lines_so_far, sloc_so_far

# RUST ==============================================================


def count_lines_rust(path_to_file, options, lang):
    """
    Count lines in a file where doubled forward slashes ('//') are the comment
    marker.  That is, we ignore blank lines, lines consisting solely of
    spaces, and those starting with zero or more spaces followed by
    doubled slashes.  Documentation lines beginning with '///' are treated as
    comments.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1         # this counts every line
                # This could be made more efficient.
                line = line.strip()
                if line and not line.startswith('//'):
                    sloc_so_far += 1      # this counts source lines
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# SHELL =============================================================


def count_lines_shell(path, options, lang):
    return count_lines_not_sharp(path, options, lang)

# SCALA =============================================================


def count_lines_scala(path_to_file, options, lang):
    lines_so_far, sloc_so_far = (0, 0)
    comment_depth = 0
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1

                code, comment_depth = uncomment_scala(line, comment_depth)
                if code:
                    code = code.strip()
                    if code:
                        sloc_so_far += 1

            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
            if comment_depth > 0:
                print("unclosed comment at end of %s" % path_to_file)

    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return (lines_so_far, sloc_so_far)


def _find_scala_code(text, comment_depth):
    """
    We are in a comment.  Return a ref to the beginning of the text
    outside the comment block (which may be '') and the value of commentDepth.
    """
    # #DEBUG
    # print("entering _findScalaCode at depth=%d; text is\n  '%s" % (
    #    commentDepth, text))
    # END

    start_multi = text.find('/*')
    end_multi = text.find('*/')
    text_back = ''

    if start_multi == -1 and end_multi == -1:
        # DEBUG
        # print("  no */, returning depth=%d, unchanged" % commentDepth)
        # END
        return text_back, comment_depth

    elif end_multi == -1 or (start_multi != -1 and start_multi < end_multi):
        # DEBUG
        # print("  found /* at %d" % startMulti)
        # END
        comment_depth = comment_depth + 1
        if start_multi + 2 < len(text):
            text_back = text[start_multi + 2:]

    else:
        # DEBUG
        # print("  found */ at %d" % endMulti)
        # END

        comment_depth = comment_depth - 1
        if end_multi + 2 < len(text):
            text_back = text[end_multi + 2:]

    # DEBUG
    # print("  returning depth=%d, textBack\n  '%s'" %
    #       (commentDepth, textBack))
    # END

    return text_back, comment_depth


def _find_scala_comment(text, comment_depth):
    """
    We are NOT at comment depth > 0.  Return a ref to any code found, a
    ref to the rest of the text, and the value of commentDepth
    """
    # DEBUG
    # if commentDepth:
    #    print("warning: entering _findScalaComment, non-zero depth %d" %
    #            commentDepth)
    # END
    multi_line = False
    posn_old = text.find('/*')       # multi-line comment
    posn_new = text.find('//')       # one-line comment

    if posn_old == -1 and posn_new == -1:
        return text, '', 0

    if posn_new == -1:
        posn = posn_old
        comment_depth = True
        multi_line = True
    else:
        # posnNew is non-negative
        if posn_old == -1 or posn_old > posn_new:
            posn = posn_new
            comment_depth = 0
        else:
            posn = posn_old
            comment_depth = 1
            multi_line = True

    if multi_line and (posn + 2 < len(text)):
        return text[:posn], text[posn + 2:], comment_depth
    return text[:posn], '', comment_depth


def uncomment_scala(text, comment_depth):
    """
    Given a line of text, return a ref to any code found and the value of
    commentDepth, which may have changed.
    """
    code = ''
    text = text.strip()
    while text:
        if comment_depth > 0:
            text, comment_depth = _find_scala_code(text, comment_depth)
        elif comment_depth == 0:
            chunk, text, comment_depth = _find_scala_comment(
                text.strip(), comment_depth)
            code += chunk   # XXX INEFFICIENT
        else:
            print("INTERNAL ERROR: negative comment depth %d" % comment_depth)

    return code, comment_depth

# SEMICOLON =========================================================


def count_lines_not_semicolon(path_to_file, options, lang):
    """
    Count lines in a file where the semicolon (';') is the comment
    marker.  That is, we ignore blank lines, lines consisting solely of
    spaces, and those starting with zero or more spaces followed by
    a semicolon.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1
                # This could be made more efficient.
                line = line.strip()
                if line and (line[0] != ';'):
                    sloc_so_far += 1
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# SNOBOL ============================================================


def count_lines_snobol(path_to_file, options, lang):
    """
    already is a set containing hashes of files already counted
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1
                line = line.rstrip()
                if line and (line[0] != '*'):
                    sloc_so_far += 1
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# TeX ===============================================================


def count_lines_tex(path_to_file, options, lang):
    return count_lines_not_percent(path_to_file, options, lang)

# TXT ===============================================================


def count_lines_txt(path_to_file, options, lang):
    """
    Count the lines in a text file.  We ignore empty lines and lines
    consisting solely of spaces.
    """

    lines_so_far, sloc_so_far = (0, 0)
    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
        if (hash_val is not None) and (lines is not None):
            for line in lines:
                lines_so_far += 1
                # This could be made more efficient.
                line = line.strip()
                if line:
                    sloc_so_far += 1
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, lines_so_far, sloc_so_far))
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
    return lines_so_far, sloc_so_far

# XML ===============================================================


def count_lines_xml(path_to_file, options, lang):
    """
    Count the lines in an xml file.  We ignore empty lines and lines
    consisting solely of spaces, and of course we ignore xml comments.
    """

    try:
        lines, hash_val = check_whether_already_counted(path_to_file, options)
    except Exception as exc:
        print("error reading '%s', skipping: %s" % (path_to_file, exc))
        return 0, 0

    try:
        line_count, sloc_so_far = (0, 0)
        if (hash_val is not None) and (lines is not None):
            line_count = len(lines)
            raw = '\n'.join(lines)
            soup = BeautifulSoup(raw, 'lxml')
            comments = soup.findAll(
                text=lambda text: isinstance(
                    text, Comment))

            # XXX THE NEXT LINE HAS NO EFFECT ?
            [comment.extract() for comment in comments]

            # -------------------------------------------------------
            # 2016:05:22 userguide.xml's soup begins with an XML decl line
            # followed by
            #  <html><body><document>
            #  <header><title> ... </header>
            #  <p>
            #  </p>
            #  <section> ...
            #
            # and ends with
            #   <p>
            #   CryptoServer will continue to serve pages until you kill it.
            #   </p>
            #   </section>
            #   </document>
            #   </body></html>
            # -------------------------------------------------------

            # PREVIOUS UNDERSTANDING:
            #   soup begins with '<html><body><p>' and ends with
            #  </p></body></html> on a separate line.

            # elm = soup.html.body.p

            # drop leading <p> and trailing </p>
            # stripped = str(elm)[3:-4]
            # lines = stripped.split('\n')

            elm = soup.html
            lines = str(elm).split('\n')

            for line in lines:
                # This could be made more efficient.
                line = line.strip()
                if line:
                    sloc_so_far += 1
                # DEBUG
                # print(line)
                # END
            options.already.add(hash_val)
            if options.verbose:
                print("%-47s: %-6s %5d lines, %5d sloc" % (
                    path_to_file, lang, line_count, sloc_so_far))
    except Exception as exc:
        print("error parsing '%s', skipping: %s" % (path_to_file, exc))
    return line_count, sloc_so_far
